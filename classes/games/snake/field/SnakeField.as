package games.snake.field 
{
    import events.RequestEvent;

    import flash.events.Event;
    import flash.events.TimerEvent;
    import flash.utils.Dictionary;
    import flash.utils.Timer;
    import flash.utils.getDefinitionByName;

    import games.snake.SnakeData;
    import games.snake.SnakeGame;
    import games.snake.snake.Snake;
    import games.snake.snake.SnakeForUser;
    import games.snake.snake.SnakePart;

    import playerio.Connection;
    import playerio.Message;

    /**
	 * ...
	 * @author Alexey Kuznetsov
	 */
	public final class SnakeField extends MovieClipContainer
	{
		private const BOOST_LENGTH:int = 28; //boost lasts for 28 1-cell moves (7 seconds)
		public static const MINES_IN_SET:int = 7;
		
		private var _snakes:Dictionary = new Dictionary();
		private var _roomCapacity:int;
		private var _mySnakeSyncTimer:Timer = new Timer(1000);
		private var _users:Array;
		private var _connection:Connection;		
		private var _fruits:Vector.<Fruit> = new Vector.<Fruit>();
		private var _mines:Vector.<Mine> = new Vector.<Mine>();
		private var _moveTimer:Timer = new Timer(31.25);
		private var _mySnake:SnakeForUser;
		private var _grid:FieldGrid;		
		
		public function SnakeField(roomCapacity:int, users:Array, myID:String, startPositions:Array, connection:Connection, fieldType:String, oppTurnData:Array) 
		{
			_connection = connection;			
			_users = users;
			_roomCapacity = roomCapacity;
			
			var assetClass:Class = getDefinitionByName(fieldType) as Class;							
			super(new assetClass(), Misc.GAME_AREA_X, Misc.GAME_AREA_Y);
			mc.cacheAsBitmap = true;		
			
			for (var j:int = 0; j < startPositions.length; j++ )
			{
				var snake;
				if (_users[j].id == myID) 
				{
					snake = new SnakeForUser(startPositions[j], _users[j].color, _connection);
					_mySnake = snake;
				}
				else 
				{
					snake = new Snake(startPositions[j], _users[j].color, oppTurnData);
					snake.addEventListener(RequestEvent.BOOST_ME, boostOppsSnake);
					trace("OPPONENT START POSITION: " + startPositions[j]);
				}
				snake.name = _users[j].id;
				snake.addEventListener(RequestEvent.PLACE_MINE, createMine);
				snake.addEventListener(RequestEvent.REMOVE_MINE, removeMine);
				addChild(snake);
				
				_snakes[_users[j].id] = snake;
			}
			setChildIndex(_mySnake, numChildren - 1); //set user's snake on top
			
			_grid = new FieldGrid();			
			_grid.visible = false;						
			
			_connection.addMessageHandler("ft", saveRandomFutureTurnOfOpponent);
			_connection.addMessageHandler("f", createFruit); //fruit was created
			_connection.addMessageHandler("bo2", boost2x);
			_connection.addMessageHandler("bo3", boost3x);
			_connection.addMessageHandler("sm", saveOppMines);
			_connection.addMessageHandler("mi", placeMissile);	
			_connection.addMessageHandler("gr", showGrid); //after grid aviability confirmation
			
			_mySnakeSyncTimer.addEventListener(TimerEvent.TIMER, syncMySnake);
			_mySnakeSyncTimer.start();	
			
			_moveTimer.addEventListener(TimerEvent.TIMER, moveSnakes);
			_moveTimer.start();
			
			_grid.scaleX = this.scaleX = Misc.GAME_AREA_WIDTH / (SnakeData.FIELD_WIDTH * SnakeData.PART_SIZE); //real field is 24 * 33 = 792px. But swf is 774. It fixed 16px difference		
			_grid.scaleY = this.scaleY = Misc.GAME_AREA_HEIGHT / (SnakeData.FIELD_HEIGHT * SnakeData.PART_SIZE); //real field is 24 * 26 = 624. But swf is 630. It fixed 6px difference
		}	
		
		private function placeMissile(message:Message):void
		{
			if (message.length < 3) //user-generated missile
			{
				(this.parent as SnakeGame).topField.missileLauncher.createMissile(_snakes[getOtherPlayerID(_mySnake.name)], _mySnake.color); //pass target snake to MissileLauncher			
			}
			else //missile generated by artificial powerups launcher
			{
				(this.parent as SnakeGame).topField.missileLauncher.createMissile(_mySnake, _snakes[getOtherPlayerID(_mySnake.name)].color, { preTargetCellI:message.getInt(0), preTargetCellJ:message.getInt(1), targetCellI:message.getInt(2), targetCellJ:message.getInt(3), launcher:_snakes[getOtherPlayerID(_mySnake.name)] });
			}
		}
		
		private function saveOppMines(message:Message):void 
		{
			trace(message);
			_snakes[getOtherPlayerID(_mySnake.name)].minePlaceRequest = { preTargetCellI:message.getInt(0), preTargetCellJ:message.getInt(1), targetCellI:message.getInt(2), targetCellJ:message.getInt(3) };
		}
		
		private function createMine(e:RequestEvent):void 
		{
			var mineItem:Mine = new Mine(e.stuff.color, e.stuff.i, e.stuff.j, e.currentTarget.name); //e.stuff.i * SnakeData.partSize + SnakeData.partSize / 2, e.stuff.j * SnakeData.partSize + SnakeData.partSize / 2
			if (SoundManager.soundsOn)
            {
                SoundManager.sounds["yo"].play();
            }
			for each (var snake:Snake in _snakes)
            {
                snake.mines.push(mineItem); //mine is dangerous for everyone except it's author
            }
			_mines.push(mineItem);
			addChildAt(mineItem, getChildIndex(_mySnake) - 1); //add mine below the snakes
		}
		
		private function removeMine(e:RequestEvent):void 
		{
			_mines[_mines.indexOf(e.stuff.mine)].mc.play();
			_mines[_mines.indexOf(e.stuff.mine)].mc.addEventListener(Event.ENTER_FRAME, function(eve:Event):void {
				if (eve.currentTarget.totalFrames == eve.currentTarget.currentFrame) 
				{
					removeChild(_mines[_mines.indexOf(e.stuff.mine)]);
					_mines[_mines.indexOf(e.stuff.mine)].mc.removeEventListener(Event.ENTER_FRAME, function(eve:Event):void { } );
					_mines.splice(_mines.indexOf(e.stuff.mine), 1);
				}
			});						
		}
		
		private function createFruit(message:Message):void 
		{
			var ii:int = message.getInt(0);
			var jj:int = message.getInt(1);
			var type:int = message.getInt(2);
			
			var fruit:Fruit = new Fruit(ii * SnakeData.PART_SIZE + SnakeData.PART_SIZE / 2, jj * SnakeData.PART_SIZE + SnakeData.PART_SIZE / 2, type, ii, jj);		
			_fruits.push(fruit);
			addChild(fruit);
			
			for (var j:int = 0; j < _mines.length; j++) //check for hittesting with mines if was not removed yet. (so fruit will not fall on the mine)
			{
				if (_mines[j].i == ii && _mines[j].j== jj)
				{	
					removeChild(fruit);
					_fruits.splice(_fruits.indexOf(fruit), 1);
					_connection.send("rf", ii, jj);//remove fruit if somehow coordinates were wrong (some snake part is at this coords)
					break;
				}
			}									
		}
		
		private function getOtherPlayerID(firstPlayerID:String):String
		{
			var result:String = "";
			for each (var item:Snake in _snakes) 
			{
				if (item.name != firstPlayerID) 
				{
					result = item.name;
					break;
				}				
			}
			return result;
		}
		
		public function turnMySnakeTo(direction:String):void { _mySnake.turnTo(direction); }		
		
		private function syncMySnake(e:TimerEvent = null):void 
		{
			var iterationsCount:int = 0;
			if (_mySnake.boostState == "") iterationsCount = 4; //speed: 4 cells/second
			else if (_mySnake.boostState == "boost2x") iterationsCount = 8;
			else if (_mySnake.boostState == "boost3x") iterationsCount = 12;
			for (var i:int = 0; i < iterationsCount; i++) _mySnake.tokens += 8; //24 px - 1 token per mini-move; 4 cells per seconds. 
		}
		
		private function saveRandomFutureTurnOfOpponent(message:Message):void 
		{
			//trace("saveRandomFutureTurnOfOpponent");
			//trace(message);
			_snakes[getOtherPlayerID(_mySnake.name)].turnsToProcess.push( { i:message.getInt(0), j:message.getInt(1), direction:SnakeData.getDirectionName(message.getInt(2)) } );
		}
		
		private function moveSnakes(e:Event):void 
		{ 			
			for each (var snake:Snake in _snakes) 
			{ 
				if (snake.tokens > 0)
				{
					var coeff:int = 1;
					if (snake.boostState != "")
					{
						if (snake.boostState == "boost2x")
                        {
                            coeff = 2;
                        }
						else if (snake.boostState == "boost3x")
                        {
                            coeff = 3;
                        }
					}
					
					for (var q:int = 0; q < coeff; q++) //normal mode, call function 6 times. 6 x 1px moves. in boost mode call it 4 times
					{
						moveSnake(snake);
						(this.parent as SnakeGame).topField.missileLauncher.tryUpdateMissiles(snake.name); //if there is a missile which is moving, move it, do effects, etc. 
					}
					
					if (snake.boostTokens == 0) removeTailTurbines(snake);
				}
			}
		}
		
		private function moveSnake(snake:Snake):void
		{
			snake.move();
			var nearbyfruits:Array = [];
			for (var i:int = 0; i < _fruits.length; i++ ) //hittesting in less than 2 cell range, no need 2 hitTest entire field
			{
				if (Math.abs(_fruits[i].x - snake.head.x) < 40 && Math.abs(_fruits[i].y - snake.head.y) < 40) nearbyfruits.push(_fruits[i]); 
			}
			
			if (nearbyfruits.length > 0)
			{
				for (var j:int = 0; j < nearbyfruits.length; j++ ) 
				{
					if (snake.head.itemGraphics.mc.mc_mc.point_for_fruits_mc.hitTestObject(nearbyfruits[j])) 
					{
						snake.growCount++;						
						snake.head.itemGraphics.mc.mc_mc.play();
						if (SoundManager.soundsOn) SoundManager.sounds["eaten"].play();
						_fruits.splice(_fruits.indexOf(nearbyfruits[j]), 1);
						dispatchEvent(new RequestEvent(RequestEvent.SHOW_POINT_CHANGE, { name:snake.name, value:1 } ));
						removeChild(nearbyfruits[j]);
					}
				}				
			}			
		}
		
		private function boost2x(message:Message):void 
		{			
			if (message.length == 0)
            {
                boostSnake(_mySnake);
            }
			else
            {
                Snake(_snakes[getOtherPlayerID(_mySnake.name)]).planBoost(message.getInt(0), message.getInt(1), message.getInt(2), message.getInt(3));
            }
		}
		
		private function boost3x(message:Message):void 
		{
			if (message.length == 0)
            {
                boostSnake(_mySnake, true);
            }
			else
            {
                Snake(_snakes[getOtherPlayerID(_mySnake.name)]).planBoost(message.getInt(0), message.getInt(1), message.getInt(2), message.getInt(3), true);
            }
		}
		
		private function boostOppsSnake(e:RequestEvent):void 
		{
			boostSnake(e.currentTarget as Snake, e.stuff.triple);
		}
		
		private function boostSnake(snake:Snake, triple:Boolean = false):void
		{
			snake.boostTokens = BOOST_LENGTH * (triple?3:2);
			snake.boostState = triple?"boost3x":"boost2x";
			snake.parts[0].itemGraphics.mc.powerups_mc.gotoAndStop(snake.boostState);
			snake.parts[0].itemGraphics.mc.powerups_mc.powerup_mc.play();
			if (SoundManager.soundsOn) SoundManager.sounds[triple?"boost3x":"boost2x"].play(); //play boost sound
		}
		
		private static function removeTailTurbines(snake:Snake):void
		{
			snake.parts[0].itemGraphics.mc.powerups_mc.gotoAndStop(1); //remove powerup
			snake.boostState = "";
		}
		
		public function clearUp():void
		{
			_mySnakeSyncTimer.stop();
			_moveTimer.stop();
			
			_connection.removeMessageHandler("f", createFruit); //fruit was created
			_connection.removeMessageHandler("bo2", boost2x);
			_connection.removeMessageHandler("bo3", boost3x);
			_connection.removeMessageHandler("mi", placeMissile);		
			_connection.removeMessageHandler("sm", saveOppMines);	
			_connection.removeMessageHandler("gr", showGrid); //after grid aviability confirmation
			
			for each (var sn:Snake in _snakes)
			{
				for each (var snp:SnakePart in sn.parts)
				{
					snp.itemGraphics.clearUp();
				}
			}
		}
		
		public function addSevenMines():void
		{					
			_connection.send("sm"); //check powerup availability. If ok - allows to add mines after.
			Misc.delayCallback(function():void
			{
				_mySnake.placeMineCounter += MINES_IN_SET;
			}, 500); //so msg will be sent			
		}
		
		private function showGrid(message:Message):void 
		{
			_grid.visible = true;
		}
		
		public function get grid():FieldGrid { return _grid; }		
	}
}